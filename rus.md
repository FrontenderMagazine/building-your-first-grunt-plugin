# Создаем плагин для Grunt впервые. #

../img/first-grunt-plugin-header.jpg

В связи с усложнением фронт-енд разработки, системы построения клиентской части набрали большой популярности. Существуют две причины развития таких сложностей с фронтом: миграция функциональных задач (обязанностей) на клиентскую сторону и все большее развитие возможностей отображения. Самая взрослая и, пожалуй, самая известная из таких систем разработки - Grunt. Благодаря своей популярности, она развила большую екосистему, где каждый разработчик может найти плагин для своих целей.

  Но, как бы там ни было, Вы все же можете столкнуться с задачей, которую еще не осуществляет ни один из готовых плагинов. В этом случае вам понадобиться изучить принципы создания собственных плагинов для Grunt. В этой статье мы покажем Вам, как создать плагин впервые, чтобы Вы потом могли создавать свои собственные.

## Начнем с grunt-init   ##

Самый простой путь, чтобы начать создавать Grunt  плагины - использование инструмента (методом метапрограммирования) grunt-init. Предполагаем, что Вы уже установили Node (и  npm), теперь установите с помощью командной строки  

    npm install -g grunt-init

Шаблон для плагина расположен на [gitHub'e](https://github.com/gruntjs/grunt-init-gruntplugin), и его нужно клонировать самостоятельно  :

    git clone https://github.com/gruntjs/grunt-init-gruntplugin.git ~/.grunt-init/gruntplugin
 
Далее нужно запустить grunt-init в папке, которую Вы подготовили для создания собственного плагина:

    grunt-init gruntplugin

Формировщик шаблонов (скаффолдер) задаст Вам множество вопросов, которые помогут определить, как лучше создать структуру папки для плагина:

../img/grunt-plugin-1.png

Grunt-init способен создавать множество разных вещей, связаных с Grunt. Полный список шаблонов и дополнительных инструкций Вы можете найти [здесь](http://gruntjs.com/project-scaffolding) .

##  Регистрируем задание

Генерируемые файлы включают большое количество дополнительных ресурсов, таких как: readme, .jshintrc, license, .gitignore, package.json. Что осообенно интересно нам, это `plugin.js` в папке задач.

Код самого плагина содержит `registerMultiTask` функция:

    grunt.registerMultiTask(taskName, [description, ] taskFunction)

Мультизадачной она называеться потому, что содержит множество кофигурационных обьектов для разных задач. Строка `taskName` будет аналогичной свойствам основного  объекта `grunt.initConfig`.   Существует отличный  [API](http://gruntjs.com/api/grunt ) для Grunt, но мы лучше посмотрим на самые важные части для нашей задачи.   В ходе решения задачи **this** содержит множество полезных методов и свойств, один из которых метод: 

    this.options()
  
Он возвращает 
 
    options

  объекта определенного в файле Grunt’а и может принимать значения по умолчанию для опций:

    var options = this.options({
    enabled: false
    });

Масив `this.files` содержит список всех пар, соответствующих паттернам конфигурации для `src` и `dest`, все глобальные паттерны должны быть обработаны до момента обращения к масиву. Большинству из Вас понадобиться цикл для этих файлов, таким образом, сгеннерированный плагин будет содержать следующие строки:  

    this.files.forEach(function(f) {
    var src = f.src.filter(function(filepath) {
      if (!grunt.file.exists(filepath)) {
        grunt.log.warn('Source file "' + filepath + '" not found.');
        return false;
      } else {
        return true;
      }
    }).map(function(filepath) {
      return grunt.file.read(filepath);
    }).join(grunt.util.normalizelf(options.separator));
    
    grunt.file.write(f.dest, src);
    
    grunt.log.writeln('File "' + f.dest + '" created.');
    });

Как Вы могли убедиться, массив  **this.files** имеет свойство `src`, которое на самом деле являеться массивом файлов. В самой обычной ситуации Вы будете фильтровать данные файлы по их расширению, содержанию или с помощью каких-то других критериев. 

`grunt.file` (http://gruntjs.com/api/grunt.file) содержит несколько полезных методов для работы с файловой системой.

`grunt.util` (http://gruntjs.com/api/grunt.util ) содержит вспомогательные функции.

`grunt.log` (http://gruntjs.com/api/grunt.log) обеспечивает необходимые методы для загрузки информации в консоль для различных груп опций. 

Последнее, на что хотелось бы обратить особое внимание, это как правильно управлять асинхронными действиями в задачах.   

    var done = this.async();
    someAsyncFunction(function(result){
      done(result);
    });

Метод `this.async` возвращает callback `done`, который должен вызываться при выполнении задачи. Если результатом является ошибка или «ложь», задача считается завершенной с «провалом».   

## Примеры плагинов  ##

 После того как вы освоите основы вндрения плагинов  Grunt, я покажу Вам несколько своих плагинов и опишу их особенности.  

### [Grep](https://github.com/msemenistyi/grunt-grep)   ###

Grep - мой самый превый плагин и, возможно, самый сложный. Он был создан с целью упростить разарботку в зависимости от ее среды. Когда нужно работать над большим приложением, Вы в любом случае столкнетесь с необходимостью работать с несколькими частями проекта в разнообразных средах програмирования или с различными параметрами.   

Заметка: в статье [Addy Osmani]( http://addyosmani.com/blog/environment-specific-builds-with-grunt-gulp-or-broccoli/) есть список похожих плагинов, зависящих от среды разработки.

Вот пример использования grep, если Вы готовите его к финальной подачи:  

#### Источник ####

    <link rel="stylesheet" href="./style.css"> <!--@grep dev-->
    <link rel="stylesheet" href="http://some.cdn/style.css"> <!--@grep production-->

#### Результат ####

    <link rel="stylesheet" href="http://some.cdn/style.css"> <!--@grep production-->

В отличии от большинства Grunt плагинов, grep не имеет никаких зависимостей, таким образом, это не просто задача, которую выполняет Grunt, но, скорее, отдельний модуль.   

Основной код Вы можете увидеть [здесь](https://github.com/msemenistyi/grunt-grep/blob/master/tasks/grep.js)   .

Главный функционал grep’a реализован путем поиска регулярных выражений. Если Вы хотите работать с содержимым файла в вашем Grunt плагине, следующий сниппет Вам пригодиться:  

    var src = grunt.util.normalizelf(src);
    var lines = src.split(grunt.util.linefeed);

Это позволит работать полноценно с текстовыми файлами, поскольку решает вопрос с  окончаниями строк, которые будет сложно деражать в памяти. Grunt больше не поддерживает хеш `grunt.util`, поэтому даю основу кода этих свойств:

      util.normalizelf = function(str) {
      return str.replace(/\r\n|\n/g, util.linefeed);
    };
    util.linefeed = process.platform === 'win32' ? '\r\n' : '\n';   

Grep также имеет много преимуществ Grunt API. Все операции с файлами - чтение, запись, проверка присутствия, сравнение файлов из папок - реализованы мотодом `grunt.file`. Если Вы планируете работать с содержимым файла, код grep будет Вам полезен.

###   [ Capo](https://github.com/msemenistyi/grunt-capo) ###

Grunt-capo тонкая обертка вокруг модуля [Capo](https://github.com/msemenistyi/capo). Короче говоря, плагин разработан для продолжительной интеграции модулей, помогая поддерживать геннерируемые  файлы в самых последних версиях. Сам по себе Capo упрощает работу с архитектурой, управляемой событиями в JavaScript, больше Вы можете почерпнуть в этой [статье](http://www.binary-studio.com/2014/2/27/javascript-event-driven-architecture-capo-module).

Основной [код](https://github.com/msemenistyi/grunt-capo/blob/master/tasks/capo.js) плагина очень лаконичный, и самая значительная часть написана всего в три строчки. Тем не менее, главной ценностью в области обучения являеться то, что данный плагин работает асинхронно, таким образом, выполнение заданий  Grant также будет выполняться асинхронно. Это достигаеться за счет метода, описанного в начале статьи, и будет полезно прочитать всю статью для более ясного представления. 

### [ Similar](https://github.com/msemenistyi/grunt-similar) ###

  Grunt-similar очень во многом зависит от самого Grunt и больше служит удобству выполнения задач с помощью интерфейса консоли (командной строки). Данный плагин определяет имя введенной задачи в Gruntfile и, в случае отказа, он проверяет, существуют ли зарегестрированные задачи с схожими именами. 

../img/grunt-plugin-2.png 

 Рассмотрим блоки построения плагина. Вот часть всех задач, которая выделяет и регистрирует новое задание  с  введенным именем:  

    if (grunt.cli.tasks.length === 1){
      var taskParts = grunt.cli.tasks[0].split(':');
      var tasks = Object.keys(grunt.task._tasks);
      if (tasks.indexOf(taskParts[0]) === -1){
        grunt.registerTask(grunt.cli.tasks[0], ['similar']);
      }
    }

`grunt.cli.tasks` массив задач, которые были введены через консоль и 
`grunt.task._tasks` масив всех задач зарегестрированных в конфигурации.

Метод `grunt.registerTask` принимает имя задачи, которую нужно зарегистрировать, и массив заданий, который нужно будет вызвать. Таким образом проксируется выполнение  похожих `similar` задач.

Еще одна строчка на заметку, это то, как плагин реализует выполнение задачи с определенным именем: 

    grunt.task.run(similarTaskName);

##   Заключение ##

Мне кажется, что для полноценного использования любой системы построения, типа  Grunt, нужно полностью понять большинство ее внутренних механизмов. Я надеюсь, что моя статья прояснила Вам это. Исследуйте основной код любого рассмотренного плагина, так как всегда лучше учиться на конкретных примерах внедрения частей модуля.   

В завершении я бы хотел обратить внимание, что уже достаточно много сказано про другие инструменты построения и про гонки производительности между ними, и что разработчики Grunt поставили себе за цель выпускать новые, слудеющие версии данного проекта. Детали об этой работе в прогрессе и ее можно найти на  [grunt-next](https://github.com/gruntjs/grunt-next).